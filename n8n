#!/usr/bin/env node

const https = require('https');
const http = require('http');
const fs = require('fs');
const path = require('path');
const { URL } = require('url');

// Configuration
const ENV_FILE = path.join(__dirname, '.env');
const WORKFLOWS_DIR = path.join(__dirname, 'workflows');
const EXECUTIONS_DIR = path.join(__dirname, 'executions');

// Ensure directories exist
[WORKFLOWS_DIR, EXECUTIONS_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Load .env file if it exists
function loadEnv() {
  if (fs.existsSync(ENV_FILE)) {
    const envContent = fs.readFileSync(ENV_FILE, 'utf8');
    envContent.split('\n').forEach(line => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        const value = valueParts.join('=').trim();
        // Remove quotes if present
        const cleanValue = value.replace(/^["']|["']$/g, '');
        process.env[key.trim()] = cleanValue;
      }
    });
  }
}

// Load config from .env file
function loadConfig() {
  loadEnv();

  // Check required env vars
  if (process.env.N8N_BASE_URL && process.env.N8N_API_KEY) {
    return {
      baseUrl: process.env.N8N_BASE_URL,
      apiKey: process.env.N8N_API_KEY,
      projectId: process.env.N8N_PROJECT_ID || ''
    };
  }

  // No config found
  console.error('‚ùå No configuration found!');
  console.error('\nCreate a .env file with your credentials:');
  console.error('  N8N_BASE_URL=https://your-n8n-instance.com');
  console.error('  N8N_API_KEY=your-api-key-here');
  console.error('  N8N_PROJECT_ID=your-project-id  # optional');
  console.error('\nRun: ./setup.sh');
  process.exit(1);
}

// HTTP request helper
function makeRequest(endpoint, method = 'GET', data = null) {
  const config = loadConfig();
  const url = new URL(endpoint, config.baseUrl);

  const options = {
    method,
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json',
      'X-N8N-API-KEY': config.apiKey
    }
  };

  return new Promise((resolve, reject) => {
    const protocol = url.protocol === 'https:' ? https : http;

    const req = protocol.request(url, options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          try {
            resolve(JSON.parse(body));
          } catch (e) {
            resolve(body);
          }
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${body}`));
        }
      });
    });

    req.on('error', reject);

    if (data) {
      req.write(JSON.stringify(data));
    }

    req.end();
  });
}

// Commands
async function listWorkflows() {
  const config = loadConfig();
  const query = config.projectId ? `?projectId=${config.projectId}` : '';
  const response = await makeRequest(`/api/v1/workflows${query}`);

  console.log('\nüìã Workflows:\n');
  response.data.forEach(wf => {
    const status = wf.active ? '‚úÖ' : '‚≠ï';
    console.log(`${status} ${wf.id} - ${wf.name}`);
  });
  console.log(`\nTotal: ${response.data.length} workflows\n`);
}

async function searchWorkflows(searchTerm) {
  const config = loadConfig();
  const query = config.projectId ? `?projectId=${config.projectId}` : '';
  const response = await makeRequest(`/api/v1/workflows${query}`);

  const term = searchTerm.toLowerCase();
  const matches = response.data.filter(wf =>
    wf.name.toLowerCase().includes(term) ||
    wf.id.toLowerCase().includes(term)
  );

  if (matches.length === 0) {
    console.log(`\n‚ùå No workflows found matching: "${searchTerm}"\n`);
    return;
  }

  console.log(`\nüîç Found ${matches.length} workflow(s) matching "${searchTerm}":\n`);
  matches.forEach(wf => {
    const status = wf.active ? '‚úÖ' : '‚≠ï';
    console.log(`${status} ${wf.id} - ${wf.name}`);
  });
  console.log('');
}

async function getWorkflowErrors(workflowId, limit = 5) {
  console.log(`\nüîç Fetching recent errors for workflow ${workflowId}...\n`);

  const response = await makeRequest(`/api/v1/executions?workflowId=${workflowId}&status=error&limit=${limit}&includeData=true`);

  if (!response.data || response.data.length === 0) {
    console.log('‚úÖ No recent errors found!\n');
    return;
  }

  console.log(`‚ùå Found ${response.data.length} failed execution(s):\n`);

  for (const exec of response.data) {
    const fullExec = await makeRequest(`/api/v1/executions/${exec.id}?includeData=true`);

    console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
    console.log(`Execution ID: ${exec.id}`);
    console.log(`Date: ${new Date(exec.stoppedAt).toLocaleString()}`);
    console.log(`Mode: ${exec.mode}`);

    // Extract error information
    const runData = fullExec.data?.resultData?.runData;
    if (runData) {
      Object.entries(runData).forEach(([nodeName, nodeData]) => {
        const node = nodeData[0];
        if (node.error) {
          console.log(`\n‚ùå Node: ${nodeName}`);
          console.log(`   Error: ${node.error.message || JSON.stringify(node.error)}`);
          if (node.error.description) {
            console.log(`   Details: ${node.error.description}`);
          }
        }
      });
    }

    // Check for lastNodeExecuted
    if (fullExec.data?.resultData?.lastNodeExecuted) {
      console.log(`\n‚ö†Ô∏è  Last executed node: ${fullExec.data.resultData.lastNodeExecuted}`);
    }

    console.log('');
  }

  console.log(`üí° Tip: Pull execution details with:\n   ./n8n pull-executions ${workflowId}\n`);
}

async function validateWorkflow(filePath) {
  console.log(`\nüîç Validating workflow: ${filePath}\n`);

  if (!fs.existsSync(filePath)) {
    console.error(`‚ùå File not found: ${filePath}\n`);
    return false;
  }

  let workflow;
  try {
    workflow = JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (error) {
    console.error(`‚ùå Invalid JSON: ${error.message}\n`);
    return false;
  }

  let valid = true;

  // Check required fields
  const requiredFields = ['name', 'nodes', 'connections'];
  requiredFields.forEach(field => {
    if (!workflow[field]) {
      console.error(`‚ùå Missing required field: ${field}`);
      valid = false;
    }
  });

  // Check nodes
  if (workflow.nodes && Array.isArray(workflow.nodes)) {
    console.log(`‚úÖ ${workflow.nodes.length} node(s) found`);

    workflow.nodes.forEach((node, idx) => {
      if (!node.name) {
        console.error(`‚ùå Node ${idx} missing name`);
        valid = false;
      }
      if (!node.type) {
        console.error(`‚ùå Node ${idx} (${node.name || 'unnamed'}) missing type`);
        valid = false;
      }
    });
  } else {
    console.error(`‚ùå Invalid nodes structure`);
    valid = false;
  }

  // Check connections
  if (workflow.connections && typeof workflow.connections === 'object') {
    console.log(`‚úÖ Connections structure valid`);
  } else {
    console.error(`‚ùå Invalid connections structure`);
    valid = false;
  }

  // Check for common issues
  if (workflow.nodes) {
    const nodeNames = workflow.nodes.map(n => n.name);
    const duplicates = nodeNames.filter((name, idx) => nodeNames.indexOf(name) !== idx);
    if (duplicates.length > 0) {
      console.error(`‚ö†Ô∏è  Warning: Duplicate node names found: ${duplicates.join(', ')}`);
    }
  }

  console.log('');
  if (valid) {
    console.log(`‚úÖ Workflow is valid!\n`);
  } else {
    console.log(`‚ùå Workflow has validation errors\n`);
  }

  return valid;
}

async function compareExecutions(workflowId, successId, failedId) {
  console.log(`\nüîç Comparing executions...\n`);

  const success = await makeRequest(`/api/v1/executions/${successId}?includeData=true`);
  const failed = await makeRequest(`/api/v1/executions/${failedId}?includeData=true`);

  console.log(`‚úÖ Success: ${successId} (${new Date(success.stoppedAt).toLocaleString()})`);
  console.log(`‚ùå Failed:  ${failedId} (${new Date(failed.stoppedAt).toLocaleString()})`);
  console.log('');

  const successNodes = Object.keys(success.data?.resultData?.runData || {});
  const failedNodes = Object.keys(failed.data?.resultData?.runData || {});

  console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
  console.log(`Node Execution Comparison:\n`);

  const allNodes = new Set([...successNodes, ...failedNodes]);

  allNodes.forEach(nodeName => {
    const successNode = success.data?.resultData?.runData?.[nodeName]?.[0];
    const failedNode = failed.data?.resultData?.runData?.[nodeName]?.[0];

    if (successNode && failedNode) {
      if (failedNode.error) {
        console.log(`‚ùå ${nodeName}`);
        console.log(`   Success: ‚úÖ (${successNode.executionTime}ms)`);
        console.log(`   Failed:  ‚ùå ${failedNode.error.message || 'Error'}`);
      } else {
        const successItems = successNode.data?.main?.[0]?.length || 0;
        const failedItems = failedNode.data?.main?.[0]?.length || 0;
        if (successItems !== failedItems) {
          console.log(`‚ö†Ô∏è  ${nodeName}`);
          console.log(`   Success: ${successItems} items`);
          console.log(`   Failed:  ${failedItems} items`);
        }
      }
    } else if (!failedNode) {
      console.log(`‚ö†Ô∏è  ${nodeName} - Not executed in failed run`);
    } else if (!successNode) {
      console.log(`‚ö†Ô∏è  ${nodeName} - Only in failed run`);
    }
  });

  console.log(`\nüí° Pull both executions for detailed analysis:`);
  console.log(`   ./n8n pull-executions ${workflowId}\n`);
}

async function pullWorkflow(workflowId) {
  console.log(`\nüì• Pulling workflow ${workflowId}...`);

  const workflow = await makeRequest(`/api/v1/workflows/${workflowId}`);
  const fileName = `${workflow.id}_${workflow.name.replace(/[^a-z0-9]/gi, '_')}.json`;
  const filePath = path.join(WORKFLOWS_DIR, fileName);

  fs.writeFileSync(filePath, JSON.stringify(workflow, null, 2));
  console.log(`‚úÖ Saved to: ${filePath}\n`);
}

async function pullAllWorkflows() {
  const config = loadConfig();
  const query = config.projectId ? `?projectId=${config.projectId}` : '';
  const response = await makeRequest(`/api/v1/workflows${query}`);

  console.log(`\nüì• Pulling ${response.data.length} workflows...`);

  for (const wf of response.data) {
    await pullWorkflow(wf.id);
  }

  console.log(`‚úÖ All workflows pulled!\n`);
}

async function pullExecutions(workflowId, limit = 10) {
  console.log(`\nüì• Pulling executions for workflow ${workflowId}...`);

  const response = await makeRequest(`/api/v1/executions?workflowId=${workflowId}&limit=${limit}&includeData=true`);

  if (!response.data || response.data.length === 0) {
    console.log('No executions found.\n');
    return;
  }

  const workflowDir = path.join(EXECUTIONS_DIR, workflowId);
  if (!fs.existsSync(workflowDir)) {
    fs.mkdirSync(workflowDir, { recursive: true });
  }

  for (const exec of response.data) {
    const fileName = `${exec.id}_${exec.mode}_${exec.finished ? 'success' : 'failed'}.json`;
    const filePath = path.join(workflowDir, fileName);

    // Try to get full execution data with all node outputs
    try {
      const fullExec = await makeRequest(`/api/v1/executions/${exec.id}?includeData=true`);
      fs.writeFileSync(filePath, JSON.stringify(fullExec, null, 2));

      // Count nodes with data
      const nodeCount = fullExec.data?.resultData?.runData ? Object.keys(fullExec.data.resultData.runData).length : 0;
      const dataInfo = nodeCount > 0 ? ` (${nodeCount} nodes)` : ' (no node data)';

      console.log(`  ‚úÖ ${exec.id} - ${exec.mode} - ${exec.finished ? '‚úÖ' : '‚ùå'}${dataInfo}`);
    } catch (error) {
      // Fallback to basic execution data if full data fetch fails
      fs.writeFileSync(filePath, JSON.stringify(exec, null, 2));
      console.log(`  ‚ö†Ô∏è  ${exec.id} - ${exec.mode} - ${exec.finished ? '‚úÖ' : '‚ùå'} (basic data only)`);
    }
  }

  console.log(`\n‚úÖ Saved ${response.data.length} executions to: ${workflowDir}\n`);
}

async function pushWorkflow(filePath) {
  console.log(`\nüì§ Pushing workflow from ${filePath}...`);

  if (!fs.existsSync(filePath)) {
    console.error(`‚ùå File not found: ${filePath}\n`);
    process.exit(1);
  }

  let workflow;
  try {
    workflow = JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (error) {
    console.error(`‚ùå Invalid JSON in file: ${error.message}\n`);
    process.exit(1);
  }

  // Only core workflow definition fields are writable via API
  const allowedFields = [
    'name',
    'nodes',
    'connections',
    'settings',
    'staticData'
  ];

  // Read-only fields (excluded automatically):
  // id, createdAt, updatedAt, versionId, versionCounter, triggerCount,
  // shared, meta, isArchived, active, tags

  if (workflow.id) {
    // Update existing workflow - filter to only allowed fields
    const updateData = {};
    allowedFields.forEach(field => {
      if (workflow[field] !== undefined) {
        updateData[field] = workflow[field];
      }
    });

    await makeRequest(`/api/v1/workflows/${workflow.id}`, 'PUT', updateData);
    console.log(`‚úÖ Updated workflow ${workflow.id}\n`);
  } else {
    // Create new workflow - filter to only allowed fields
    const createData = {};
    allowedFields.forEach(field => {
      if (workflow[field] !== undefined) {
        createData[field] = workflow[field];
      }
    });

    const response = await makeRequest('/api/v1/workflows', 'POST', createData);
    console.log(`‚úÖ Created workflow ${response.id}\n`);
  }
}

// CLI
const command = process.argv[2];
const arg = process.argv[3];

async function main() {
  try {
    switch (command) {
      case 'list':
        await listWorkflows();
        break;

      case 'search':
        if (!arg) {
          console.error('Usage: n8n search <term>');
          process.exit(1);
        }
        await searchWorkflows(arg);
        break;

      case 'errors':
        if (!arg) {
          console.error('Usage: n8n errors <workflow-id> [limit]');
          process.exit(1);
        }
        const errorLimit = process.argv[4] || 5;
        await getWorkflowErrors(arg, errorLimit);
        break;

      case 'validate':
        if (!arg) {
          console.error('Usage: n8n validate <workflow-file.json>');
          process.exit(1);
        }
        await validateWorkflow(arg);
        break;

      case 'compare-executions':
        if (!arg || !process.argv[4] || !process.argv[5]) {
          console.error('Usage: n8n compare-executions <workflow-id> <success-execution-id> <failed-execution-id>');
          process.exit(1);
        }
        await compareExecutions(arg, process.argv[4], process.argv[5]);
        break;

      case 'pull':
        if (arg === 'all' || !arg) {
          await pullAllWorkflows();
        } else {
          await pullWorkflow(arg);
        }
        break;

      case 'pull-executions':
        if (!arg) {
          console.error('Usage: n8n pull-executions <workflow-id> [limit]');
          process.exit(1);
        }
        const limit = process.argv[4] || 10;
        await pullExecutions(arg, limit);
        break;

      case 'push':
        if (!arg) {
          console.error('Usage: n8n push <workflow-file.json>');
          process.exit(1);
        }
        await pushWorkflow(arg);
        break;

      case 'help':
      default:
        console.log(`
n8n CLI - Manage workflows locally

Usage:
  n8n list                                    List all workflows
  n8n search <term>                           Search workflows by name
  n8n errors <workflow-id> [limit]            Show recent errors for a workflow
  n8n validate <file.json>                    Validate workflow JSON before pushing
  n8n compare-executions <wf-id> <ok> <fail>  Compare successful vs failed executions
  n8n pull [workflow-id|all]                  Pull workflow(s) to local JSON files
  n8n pull-executions <id> [limit]            Pull execution data for a workflow
  n8n push <file.json>                        Push local workflow changes to n8n
  n8n help                                    Show this help

Examples:
  n8n search "Todoist"
  n8n errors mp3KdoJFgCDT5ktt
  n8n validate workflows/mp3KdoJFgCDT5ktt_Workflow.json
  n8n compare-executions mp3KdoJFgCDT5ktt 437776 440301
  n8n pull all
  n8n pull mp3KdoJFgCDT5ktt
  n8n pull-executions mp3KdoJFgCDT5ktt 20
  n8n push workflows/mp3KdoJFgCDT5ktt_Employee_Education_Plans.json

Files are stored in:
  ./workflows/     - Workflow JSON files
  ./executions/    - Execution data organized by workflow ID
        `);
    }
  } catch (error) {
    console.error(`\n‚ùå Error: ${error.message}\n`);
    process.exit(1);
  }
}

main();
